\documentclass[12pt,letterpaper]{report}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[right=2cm,left=3cm,top=2cm,bottom=2cm,headsep=0cm,footskip=0.5cm]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{amsmath, amsthm, amssymb, amsfonts}

\frenchspacing
\title{\Huge Diccionarios \\ Tarea 2 - Diseño y Análisis de Algoritmos \\ Informe}
\author{Nicolás Salas V.}
\def\thesection       {\arabic{section}}
\sloppy

\begin{document}
\begin{figure}[t]
\includegraphics[scale=0.83]{logo.png}
%\hspace{3.5cm}
\begin{tabular}{l}
\small Universidad de Chile\\
\small Facultad de Ciencias Físicas y Matemáticas\\
\small Departamento de Ciencias de la Computación\\
\small CC4102 Diseño y Análisis de Algoritmos\\
\small Prof: Gonzalo Navarro B.
\vspace{2.3cm}
\end{tabular}
\end{figure}

\maketitle

\tableofcontents
\newpage

\section{Introducción}
El objetivo de este informe es comparar las implementaciones de diccionarios mediante \'arboles de b\'usqueda. En particular se estudiar\'a los siguientes casos:

\begin{itemize}
\item \'Arbol de b\'usqueda binaria
\item \'Arbol AVL
\item Splay Tree
\item \'Arbol de Van Emde Boas
\end{itemize}

Interesa -como en cualquier experimento de eficiencia de estructuras- saber cu\'al es la mejor estructura posible para implementar diccionarios. De nuevo, el experimento es entre las cuatro estructuras antes mencionadas. Hay otras estructuras que implementan diccionarios que pueden ser mejores, pero se quiere evaluar estas cuatro.\\

Aunque lo ideal sería encontrar una estructura que fuese mejor que todas las otras, esto probablemente no ocurrirá\footnote{Sobre esto se discute en la próxima sección, de Hipótesis.}, debido a las implementaciones de cada estructura. Con esa limitante, interesa saber cuáles son las mejores estructuras para qué casos.\\

Para partir, se expone un pequeño resumen de cada estructura de datos, que se analizarán a fondo en la sección de Diseño Experimental. Se asumen conocimientos básicos de computación, en particular se asume que se conoce lo que es una estructura de datos, lo que significa recursividad y dominio básico de punteros. En los anexos se muestra dónde se puede investigar lo que son estos conceptos.\\

\subsection{Árbol de Búsqueda Binaria}
\label{subsec:expl_abb}

Un Árbol de Búsqueda Binaria no es más que una estructura de datos que almacena un dato comparable y dos punteros a hijos que también son árboles. Este árbol cumple con la propiedad de que todos los elementos almacenados en los nodos de su subárbol izquierdo son menores al valor almacenado en el nodo \emph{raíz} y de igual manera, los elementos almacenados en los nodos de su subárbol derecho con mayores al valor de la raíz. \textbf{Esta propiedad la cumple tanto este tipo de árbol como los árboles AVL, los Splay Trees y otro tipo de árboles que no se estudian en este experimento}. La inserción y borrado se explica en la sección de diseño experimental, pero es importante tener en cuenta que dichas operaciones \textbf{no rearreglan el árbol}, de manera que la búsqueda no siempre cumple con la propiedad de ser logarítmica.

\subsection{Árbol AVL}
\label{subsec:expl_avl}
Un Árbol AVL es un árbol de búsqueda binaria, pero que rearregla sus elementos a medida que se insertan, para mantenerse balanceado, en inglés este tipo de estructuras se llaman \emph{self balancing binary search tree}, que significa Árbol de Búsqueda Binaria Autobalanceado. Los AVL mantienen la diferencia de altura de sus dos subárboles constante, con ello se asegura que el tiempo de búsqueda, y en general de las operaciones sobre estos árboles sea logarítmica.

\subsection{Splay Tree}
\label{subsec:expl_splay}

Un Splay Tree es un árbol de búsqueda binaria que no se preocupa de mantenerse balanceado\footnote{En cierto modo, sí lo hace, pero esta perspectiva se abordará en la sección de Diseño Experimental.}, sino que su preocupación principal es mantener los elementos accesados con mayor frecuencia \emph{más arriba} en el árbol. Es decir, minimiza el número de comparaciones (o, dicho de otra manera, accesos a nodos) para elementos que son buscados frecuentemente.

\subsection{Árbol de Van Emde Boas}
\label{subsec:expl_veb}

Un Árbol de Van Emde Boas es.. \texttt{Pendiente}.

\subsection{Mediciones}
\label{subsec:mediciones}

Para comparar la efectividad de cada una de estas estructuras de datos, es necesario tomar algunos parámetros objetivos. En este caso, un buen parámetro que nunca falla es \textbf{el tiempo}. Además, es conocido que algunas estructuras pesan más que otras, así que también se medirá el \textbf{Tamaño ocupado por cada estructura}. En base a estas dos mediciones se pueden inferir otras medidas de rendimiento, o incluso comparar los resultados reales contra la teoría. Esto se expone en las secciones de Resultados y Análisis de Datos.


\section{Hipótesis}
Ya conociendo a grandes rasgos lo que hace cada árbol es posible elaborar algunas hipótesis sobre este experimento, y por supuesto, los argumentos para que ello sea así.\\

Los Splay Tree no se quedan en la noción de que todo árbol debe ser balanceado. ?`Por qué deberían balancearse elementos que nunca van a ser buscados en una estructura? Esta simple noción hace que sean una estructura mucho más adaptada a la realidad, donde la cantidad de elementos que se buscan está -haciendo una estimación generosa- no más allá del 20\% de los elementos\footnote{En verdad, esta afirmación sobre los splay trees adaptándose a la realidad tiene que ver con la predilección del autor por esta estructura. De todas maneras, lo expuesto no dista mucho de la realidad}. O sea, los Splay Trees han de ser mucho mejores que los otros tipos de árboles para casos reales, justamente porque lo que más se busca siempre está ``a mano''.\\

Sobre los Árboles de Búsqueda Binaria (en adelante \emph{ABB}) y AVL es sabido que los ABB tienen casos degenerados en los que se comportan como si fuesen listas enlazadas, esto pasa específicamente cuando los elementos se insertan ordenadamente. Este es un caso más bien extraño, pero en ningún momento imposible, de manera que los AVL son mejores que los ABB para casos degenerados. Sin embargo, en la teoría los AVL son mejores que los ABB, porque sus costos son siempre $O(\log n)$, pero lo que la notación obvía, es que existe un costo adicional -en la literatura es conocido como \emph{overhead}- asociado a el rebalanceo en la inserción y borrado. Los experimentos deberían indicar que, en promedio, los AVL se demoran más en insertar y borrar que los ABB.\\

Respecto de los Van Emde Boas, deberían ser los árboles que lo hagan más rápido de todos al poder \emph{mapear} los posibles inputs a un conjunto \emph{discreto}, sin embargo el espacio que ocupan estos árboles es \textbf{gigante}, puesto que siempre asumen que todo el ``universo'' estará presente. Es decir, deberían tener siempre el peor almacenamiento, pero la búsqueda más rápida.\\

Sobre el espacio, el árbol AVL ocupa $O(1)$ espacio más que un ABB convencional por nodo, puesto que cada uno debe almacenar su altura para poder rebalancearse, esto hace que los AVL sean más pesados que los ABB. Por otro lado, los Splay Tree no tienen overhead asociado al espacio, puesto que el reordenamiento de nodos no implica necesariamente rebalanceo, así que para espacio los Splay Tree deberían tener siempre el mismo espacio que los ABB.\\

La discusión anterior puede dar una última hipótesis sobre los Splay Tree comparados con los ABB. Entre ellos dos no hay diferencias de espacio, y respecto de los costos de las operaciones, ABB tiene costo \textbf{promedio} $O(n)$, mientras que los Splay Tree tienen costo \textbf{amortizado} $O(n)$. Vale la pena discutir cuál es mejor usar en la práctica, porque ambos costos son conceptualmente muy parecidos, y ambos ocupan el mismo espacio para la estructura de datos. Para conjeturar, los Splay Tree debieran ser mejores que los ABB \textbf{si es que no se sabe nada del input}, pero los ABB deberían ser mejor si se tiene la certeza de que el input viene desordenado.\\

Resumiendo:

\begin{enumerate}
\item Un Splay Tree se comporta mejor si hay elementos con mayores probabilidades de acceso que otros.
\item Un AVL es mejor en casos degenerados con probabilidades uniformes (o desconocidas) de acceso.
\item El Van Emde Boas es el árbol más rápido de todos en un universo discreto de llaves.
\item El mejor espacio está entre ABB y Splay Tree.
\item El peor espacio lo tiene van Emde Boas.
\item Los AVL ocupan más espacio que los Splay Tree y los ABB.
\end{enumerate}

\section{Diseño Experimental}
En esta sección se presentan todos los detalles que se tomaron en cuenta para implementar las distintas estructuras de datos y para medir el tiempo. Entre esos detalles, se presentan:
\begin{enumerate}
\item Lenguaje de Preferencia.
\item Detalles de Implementación de todas las estructuras y sus algoritmos.
\item Elaboración de los Casos de Prueba según las Hipótesis
\end{enumerate}

\subsection{Lenguaje de Preferencia}
\label{subsec:lenguaje}
Para este experimento es \textbf{crucial} no tener \emph{metadatos} asociados a las estructuras, porque añaden valores que no se quieren, en ningún caso, medir. Esto significa que se necesita un lenguaje en el que:
\begin{enumerate}
\item Sea fácil medir tamaños de las estructuras.
\item Sea fácil usar punteros, por la naturaleza de las estructuras.
\item Se pueda medir el tiempo transcurrido fehacientemente
\end{enumerate}

Y, aunque no sea imprescindible, siempre es deseable que el lenguaje sea rápido, para no esperar demasiado tiempo los resultados.\\

Por lo anteriormente expuesto, el lenguaje que mejor calza con esto es \texttt{C}, aunque \texttt{C++} hubiese hecho el trabajo igual de bien. Escoger C sobre C++ es sólo por el dominio del autor de este informe sobre C. Además, la manipulación de bits necesaria para implementar los árboles de van Emde Boas es un beneficio al que no es fácil renunciar.

\subsection{Detalles de Implementación}
\label{subsec:detalles}
En este apartado se muestra cómo se han implementado las distintas estructuras de datos, indicando cuando corresponda por qué se ha decidido así. Los algoritmos de cada estructura se exponen en pseudocódigo, de ser necesario, en los apéndices se incluye el código real en \texttt{C} de los algoritmos que necesiten explicación más profunda.

\subsubsection{Árbol de Búsqueda Binaria}

\subsubsection{Árbol AVL}

\subsubsection{Splay Tree}

\subsubsection{Árbol de van Emde Boas}


\subsection{Casos de Prueba}
\label{subsec:casos_prueba}
Describir los casos de prueba.


\section{Resultados}
\section{Análisis e Interpretación de los Datos}
\section{Apéndices}
\subsection{Dominio Básico}
\label{subsec:apen_dombasico}
Como se mencionaba al principio, en este apéndice se introducen algunos conceptos necesarios para entender este informe. Dichos conceptos son recursión, punteros y estructuras de datos. Aquí se da una definición lo suficientemente sucinta para entender el informe, sin embargo, también se proveen links para entender estos conceptos a fondo, en caso de que el lector tenga interés en ello.

\subsubsection{Recursión}

Recursión, en general, es un concepto que indica que alguna cosa depende de sí misma. En el área de ciencias de la computación, la recursión de una función indica que calcular el valor de ella depende de una invocación a ella misma, generalmente con un argumento distinto. Por ejemplo, dado que las potencias son recursivas, se puede calcular la $n$-ésima potencia de 2 como sigue:

\begin{verbatim}
int potencia_de_2(int n){
  if(n==0) return 1;
  return potencia_de_2(n-1);
}
\end{verbatim}

Como se aprecia, esta función se calcula invocándose a sí misma con un argumento distinto. La segunda línea indica que cuando $n$ vale 0, entonces se retorna 1 y entonces la \emph{recursión se detiene}. Entender este concepto es fundamental para entender estructuras de datos recursivas. Esto se explica más adelante.\\

Existen muchos otros puntos de vista asociados a la reccursión. Para ir más allá del alcance de este informe se puede revisar la entrada de Wikipedia: https://es.wikipedia.org/wiki/Recursi\%C3\%B3n.

\subsubsection{Punteros}
Un puntero es una variable que almacena una dirección en memoria. Aunque la definición es correcta y no parece que haya mucho más que decir, es necesario entender algunas cosas.\\

Los punteros tienen tipos, es decir, un puntero puede apuntar hacia una dirección de memoria que almacena \texttt{int}, o \texttt{char}, o \texttt{struct arbol}. Al acceder a las direcciones de memoria a la que los punteros apuntan, lo único que se hace es \textbf{interpretar el pedazo de memoria indicado como el tipo del puntero}. O sea, si en una aplicación existe un puntero a \texttt{int} y se accede a él. Se toman 4 bytes de memoria (tamaño de un \texttt{int}) y se interpretan como si fuera un entero. Lo mismo sucede con las estructuras de datos (se explican en la próxima subsección).\\

Para este trabajo, los punteros son importantes porque permiten \emph{desacoplar} el espacio en el que habita una estructura de datos grandes, es decir, no es necesario que los datos residan en bloques continuos de memoria, gracias a los punteros, se puede acceder a estos datos sin tener que duplicar las entradas de cada nodo en los árboles.\\

Los punteros son un área compleja y muy interesante de los lenguajes de programación. El profesor Jerry Cain en Stanford explica el concepto bastante bien en las clases del curso CS107 - Programming Paradigms, que se puede ver en YouTube: https://www.youtube.com/watch?v=jTSvthW34GU&list=PL9D558D49CA734A02.

\subsubsection{Estructura de Datos}
Una estructura de datos es un conjunto de datos que se agrupan en otro. Puede parecer no muy potente al principio, pero añadiendo el concepto de recursión y punteros es posible potenciarlas bastante, y es precisamente esta funcionalidad del lenguaje \texttt{C} la que permite escribir árboles tan fácilmente. Supóngase que se necesita crear una estructura árbol que almacene números, entonces lo único que hay que hacer es lo siguiente:
\begin{verbatim}
struct arbol{
  int valor;
  struct arbol *hijo_derecho;
  struct arbol *hijo_izquierdo;
};
\end{verbatim}
Lo que indica esta estrctura es que cada árbol tiene un valor y dos subárboles hijos: uno izquierdo y uno derecho. Cada subárbol es a su vez otro árbol que tiene la misma propiedad. Usando de los punteros, que cuando uno de ellos es \texttt{NULL}, se puede terminar la recursión. Este enfoque es el que se usa en la práctica de las implementaciones de los árboles que se usaron para este experimento.\\

Para investigar más sobre estructuras de datos se puede leer la entrada en Wikipedia. Explicar las estructuras de datos más comunes es usualmente un curso entero. https://en.wikipedia.org/wiki/Data\_structure.

\subsection{Ambiente de Ejecución}
\label{subsec:ambiente}

Entendiendo que los resultados varían dependiendo del procesador de la máquina donde se ejecuta el experimento, se incluyen las características del computador donde fue ejecutado el experimento.\\

\begin{tabular}{ll}
  Sistema Operativo & Arch Linux, Kernel 4.2.5-1-ARCH\\
  Procesador & Intel Core i5-2500k @ 3.3 GHz\\
  Memoria Disponible & 12 GiB\\
  Tamaño de un puntero & 8 bytes (64 bits)\\
\end{tabular}

Usalmente al tamaño de un puntero (en la jerga de arquiterctura se le conoce como tamaño de palabra, o \emph{word size}) se le denomina tipo del sistema. Los más comunes son 64 bits en las máquinas nuevas y 32 bits en las máquinas un poco más viejas.

\subsection{Estadística de los resultados}
\label{subsec:estadistica}

Entendiendo que siempre existe algo que genera \emph{ruido} en las mediciones de los tiempos, es necesario \emph{normalizar} estos resultados para presentar resultados creíbles de calidad. Entre los factores que generan ruido (de los que no se pueden controlar) están:

\begin{itemize}
\item El Scheduler del Sistema Operativo
\item La aleatorización de algunos inputs
\item Uso de memoria externa en caso de necesitarla (por parte del Sistema Operativo)
\end{itemize}

Entonces, para normalizar estos datos se hace uso de la estadística. El objetivo es entregar el promedio de muchas mediciones, tal que el error asociado al promedio entregado no supere el 95\%. En adelante se dirá que un resultado es tal \emph{con un 95\% de confianza}. Para hacer esto se calculan los estimadores insesgados del promedio y la desviación estándar para los valores que se quiere calcular (en este caso, tiempo y espacio). Se repiten los experimentos hasta que el promedio ($\mu$) y la desviación estándar ($\sigma$) no superen el error esperado. Esto es, el 5\%. Matemáticamente se puede expresar de la siguiente forma.

\begin{align}
  \mu &= \sum_{i=1}^n X_i \nonumber \\
  \sigma &= \sqrt{\dfrac{\sum_{i=1}^n (X_i - \mu)^{2}}{n-1}} \nonumber \\
  \sigma &= \sqrt{\dfrac{\sum_{i=1}^n X_i^2 - n\mu^2}{n-1}} \nonumber \\
  \varepsilon &= \dfrac{\sigma}{\sqrt{n}} \nonumber
\end{align}

Con las ecuaciones anteriores se pueden calcular estimadores para el promedio ($\mu$), la desviación estandar ($\sigma$) y el error ($\varepsilon$). Para todos los experimentos se ha definido la máxima tolerancia para el error como el 5\% del promedio. Esto es:
$$\varepsilon < 0.05\cdot \mu$$
La condición anterior asegura que los datos entregados corresponden a valores estadísticamente aceptable, y eliminan casos de \emph{outliers}\footnote{Un outlier corresponde a un valor extremadamente alejado de la media, de manera que \emph{contamina} la medición del promedio.}, o casos extremadamente extraños en caso de existir inputs probabilísticos (que los hay).


\end{document} 
